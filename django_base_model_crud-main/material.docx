Модуль 9
Тема: Запис даних. Вибір даних.
На попередньому занятті ми дізнались, що таке міграції, як їх використовувати, навіщо вони потрібні. Також ми більш детально подивимось на моделі та розберемо їх.
Опис: На поточному занятті ми дізнаємось, що таке запис даних, як його використовувати, навіщо він потрібні та як вони можуть спростити роботу з даними. Також ми більш детально подивимось на вибір даних.
Домашнє завдання:
Завдання
Розробити п'ять моделей, перша модель є студентом університету, вказати у нього поля ім'я, прізвище, номер студентської карти, та інші (наприклад пошта). Створити модель група студента, додати студенту номер групи, додати до моделі інші поля, наприклад, гасло групи або кабінет зборів. Після цього додати модель карти для доступу до бібліотек з полями дата видачі, дата закінчення, ціна та інше. Зв'язати студента зі студентською картою, додавши нові поля студенту чи картці. Створити модель літератури бібліотеки, додати поля назву, жанр, дату видання, рік та інші. Створити модель "Процес взяття книги", в даній моделі мають бути поля, хто книгу взяв(номер карти бібліотеки), яку книги взяли(тобто номер або назву літератури), дата взяття книги, та ПІБ людини, яка цю книгу дала, зв'язати цю модель з Картою бібліотеки та Літературою.
Переглянути можливий код
 from django.db import models


class Student(models.Model):
    name = models.CharField(max_length=30)
    surname = models.CharField(max_length=30)
    student_card_number = models.CharField(max_length=10, unique=True)
    email = models.EmailField()


    def __str__(self):
        return f"{self.name} {self.surname}"
    


class StudentGroup(models.Model):
    group_number = models.CharField(max_length=10, unique=True)
    slogan = models.CharField(max_length=100)
    meeting_room = models.CharField(max_length=30)


    def __str__(self):
        return f"Group {self.group_number}"
    


class LibraryCard(models.Model):
    student = models.OneToOneField(Student, on_delete=models.CASCADE)
    issue_date = models.DateField()
    expiration_date = models.DateField()
    price = models.DecimalField(max_digits=8, decimal_places=2)


    def __str__(self):
        return f"Library Card for {self.student}"
    


class LibraryLiterature(models.Model):
    name = models.CharField(max_length=100)
    genre = models.CharField(max_length=50)
    publication_date = models.DateField()
    year = models.PositiveIntegerField()


    def __str__(self):
        return self.name
    


class BookBorrowing(models.Model):
    library_card = models.ForeignKey(LibraryCard, on_delete=models.CASCADE)
    literature = models.ForeignKey(LibraryLiterature, on_delete=models.CASCADE)
    borrowing_date = models.DateField()
    borrower_name = models.CharField(max_length=30)


    def __str__(self):
        return f"{self.literature} borrowed by {self.borrower_name}"




Запис даних
Моделі мають спростити роботу з даними, що зберігаються в інформаційній базі. У тому числі полегшити запис даних до бази. 
Найпростіше виправити вже наявний у моделі запис. Для цього потрібно залучити її якимось чином.
from GoITeenoard.modeIs import GoITeen
b = GoITeen.objects .get (pk=6) 
Тут ми в консолі Django отримуємо оголошення з ключем б Занести в поля отриманого запису нові значення можна, просто надавши їх ат рибутам класу моделі, що представляють ці поля:
b.title = 'place'
b.content = ‘big’
b.price = 100000
Після цього залишиться виконати збереження запису, викликавши метод save() моделі
b. save ()
Оскільки цей запис має ключ (її ключове поле заповнено), Django відразу дізнається, що він вже був раніше збережений у базі, і виконає оновлення, відправивши СУБД SQL-команду update
Створення записів
Створити новий запис у моделі можна трьома способами
1. створити новий екземпляр класу моделі, викликавши конструктор без параметрів, занести в поля потрібні значення та зберегти запис, викликавши у неї метод save():
from GoITeenoard.models import Rubric
r = Rubric ()
r.name = ‘Vacuum’
r.save () 
2. створити новий екземпляр класу моделі, вказавши значення полів у виклику конструктора — через однойменні параметри, і зберегти запис:
г = Rubric(name=‘Vacuum’) 
г. save () 
3. всі класи моделей підтримують атрибут objects, в якому зберігається диспетчер записів — об'єкт, що представляє всі записи, що зберігаються в моделі, і є екземпляром класу Manager З модуля django.db.models. Клас Manager підтримує метод create (), який приймає з іменованими параметрами значення полів створюваного запису, створює цей запис, відразу ж зберігає і повертає як результат. Ось приклад використання цього методу:
г = Rubriс.objects.create(name=‘Vacuum’)
r.pk
Перевірити, чи збережено запис, можна, запитавши значення його ключового поля (воно завжди доступне через універсальний атрибут класу рк). Якщо воно зберігає значення, значить запис був збережений. При створенні нового запису будь-яким із описаних раніше способів Django перевіряє значення її ключового поля. Якщо таке зберігає порожній рядок або None (тобто ключ відсутній), фреймворк цілком резонно передбачає, що запис потрібно додати в базу, і виконує її додавання посилкою СУБД SQL-команди insert. Якщо вже зайшла мова про диспетчера записів Manager, то потрібно розповісти ще про пару корисних методів, які він підтримує: 
get_or_create (<набір фільтрів>[, defaults=None] ) шукає запис на основі заданого набору фільтрів. Якщо відповідний запис не буде знайдено, метод створить і збереже його, використавши набір фільтрів для вказівки значень полів нового запису. Необов'язковому параметру defaults можна присвоїти словник, що вказує значення для інших полів створюваного запису (мається на увазі, що модель не містить поля з ім'ям defaults. Якщо ж таке поле є і по ньому потрібно виконати пошук, то слід використовувати фільтр виду defaults__exact)
Як результат метод повертає кортеж із двох значень: 
запису моделі, знайденої у базі чи створеної щойно; 
True, якщо цей запис був створений, або False, якщо він був знайдений у базі. Приклад:
Rubric.objects.get_or_create (name= ‘Vacuum’)
Rubric.obj ects.get_or_create(name=’Cleaner’)
Увага! 
Метод get or create () здатний повернути лише один запис, який відповідає за даним критеріям пошуку. Якщо таких записів у моделі виявиться більше однієї, то буде збуджено виключення MultipleObjectsReturned З МОДУЛЯ django. core, exceptions. 
update_or_create (<набір фільтрів>[defaults=None]) — аналогічний методу get_or_create, але у разі, якщо запис знайдено, заносить у його поля нові значення, задані у словнику, який вказаний у параметрі defaults. Приклад:
Rubric.objects.update_or_create (name= ‘Flowers’)
Rubric.objects.update_or_create(name=’Flowers’, defaults={’name’:’Plants’})
У полі зі списком , в якому перелік доступних значень представлений послідовністю Python, слід заносити внутрішнє значення, призначене для запису в полі:
b.kind = ’b’
b. save ()
Якщо ж перелік значень представлений перерахуванням, то поле потрібно заносити елемент перерахування:
m = Measure ()
m.measurement = Measure.Measurements.FEET
Метод save()
Формат виклику методу save() моделі, що зберігає запис
save([update_fields=None][,][force insert=False][,][force_update=False]
Необов'язковий параметр update_fields вказує на послідовність імен полів моделі, які потрібно оновити. Його має сенс задавати тільки при оновленні запису, якщо були змінені значення не всіх, а одного або двох полів, і якщо поля, що не зазнали оновлення, зберігають об'ємні дані (наприклад, великий текст у полі текстового типу). Приклад:
Ь = GoITeen. objects. get (pk=6)
b.title = ‘Place’
b. save (update_fields= [ ’ title ’ ]
Якщо параметр update fields не заданий, буде оновлено всі поля моделі. Якщо параметрам force insert і force update задати значення False, то Django сам прийматиме рішення, створити новий запис або оновити наявну (на основі чого він приймає таке рішення, ми вже знаємо). Однак ми можемо явно вказати йому створити або змінити запис, надавши значення True параметру force insert АБО force update відповідно. 
Таке може стати в нагоді, наприклад, у випадку, якщо якась таблиця містить ключове поле не цілого чисельного автоінкрементного, а якогось іншого типу, наприклад, рядкового. Значення в таке поле при створенні запису доведеться заносити вручну, але при збереженні запису, з'ясувавши, що ключове поле містить значення, Django вирішить, що цей запис вже був збережений раніше, і спробує оновити його, що призведе до помилки. 
Щоб виключити таку ситуацію, при викликі методу save() слід задати параметр force insert зі значенням True. Тут потрібно мати на увазі дві особливості. По-перше, завдання списку оновлюваних полів у параметрі update fields автоматично дає параметру force update значення True (тобто явно вказує на оновлення запису). По-друге, вказівка True для обох описаних раніше параметрів викликає помилку.
Видалення записів
Для видалення запису достатньо викликати у неї метод delete():
b = GoITeen.objects.get (pk = 7)
b.delete()
Метод delete про повертає як результат кортеж. Його першим елементом стане кількість віддалених записів у всіх моделях, що є у проекті. Другим елементом є словник, у якому ключі елементів представляють окремі моделі, які значення — кількість видалених їх записів. Особливої практичної цінності цей результат не становить.
Django надає ряд інструментів для зручної роботи зі зв'язаними записами: створення, встановлення та видалення зв'язку.
Зв'язати запис вторинної моделі із записом первинної моделі можна, привласнивши
поля зовнішнього ключа в записі вторинної моделі потрібний об'єкт-запис первинної моделі, наприклад:
г = Rubric.objects.get(name=’Plants’)
b = GoIteens()
b.title = ‘Flower’
b.content = ‘Red’
b.price = 100
b. rubric = г
b. save()
Вказати об'єкт-запис первинної моделі можна і у викликі методу create про диспетчера записів:
b = GoITeen.objects.create(title=’Some’, content='thing', price = 50, rubric = r)
Так само виконується зв'язування запису вторинної моделі з іншого
записом первинної таблиці:
r2 = Ruhriс.objects.get(name=’Vacuum’)
b.rubric = r2
b. save()
Модель, що представляє запис первинної таблиці, отримує атрибут з ім'ям виду <ім'я пов'язаної вторинної моделі>_set. Він зберігає екземпляр класу RelatedManager З модуля django.db.models, fields, related, що представляє набір пов'язаних записів вторинної таблиці і називається диспетчером зворотного зв'язку. 
Увага! Описаний раніше атрибут класу отримує ім'я <ім'я пов'язаної вторинної моделі>_set за замовчуванням. Однак це ім'я можна змінити при оголошенні поля зовнішнього ключа, вказавши його в параметрі related_name 
Клас RelatedManager підтримує два дуже корисні методи: 
add(<зв'язується запис 1>, <зв'язується запис 2> . .  [, buik=True]) — пов'язує з поточним записом первинної моделі запису вторинної моделі, передані як параметри. 
Якщо значення параметра bulk дорівнює True, то записи будуть пов'язані безпосередньо віддачею СУБД SQL-команди, без маніпуляцій з об'єктами моделей, що представляють записи, що зв'язуються. Ця поведінка за умовчанням, і вона дозволяє збільшити продуктивність. 
Якщо значення параметра bulk дорівнює False, то записи будуть зв'язуватися за допомогою маніпуляцій об'єктами моделі, що представляють записи, що зв'язуються. Це може стати в нагоді, якщо клас моделі містить перевизначені методи save() та delete(). До моменту виклику методу add() поточний запис первинної моделі має бути збережений. 
Не забуваймо, що в полі зовнішнього ключа запису вторинної моделі зберігається ключ запису первинної моделі, а він може бути отриманий тільки після збереження запису (якщо в моделі використовується стандартне ключове поле цілочисленного автоінкрементного типу). Приклад
r = Rubric.objects.get(name=’Crew')
b = GoITeen.objects.create(title=’Hummer’, content='Black', price=20)
r.GoITeen_set.add(b)
b.rubric
create() — метод успадкований від класу Manager і, крім створення запису вторинної моделі, також виконує її зв'язування з поточним записом первинної моделі:
b2 = r.GoITeen_set.create(title=’Hummer’, content='White', price=1000) 
Такий зв'язок дуже проста, відповідно, програмних інструментів для її встановлення Django надає небагато. Зв'язати записи вторинної та первинної моделі можна, надавши запис первинної моделі полю зовнішнього ключа запису вторинної моделі. Ось приклад створення запису вторинної моделі Adviser і зв'язування її із записом первинної моделі user, що представляє користувача admin:
au = AdvUser.objects.create(user=u)
Первинна модель при цьому отримає атрибут, що зберігає пов'язаний запис вторинної моделі. Ім'я цього атрибуту збігатиметься з ім'ям вторинної моделі. Отже, зв'язати записи первинної та вторинної моделі можна, надавши запис
вторинної моделі описаного раніше атрибуту. Ось приклад зв'язування запису моделі User З іншим записом моделі AdvUser:
au2 = AdvUser.objects.get(рк=2)
u.advuser = au2
u. save ()
u.advuser
Обробка зв'язку "багато з багатьма"
Якщо між двома моделями був встановлений зв'язок такого роду, то перед власне зв'язуванням записів нам обов'язково потрібно їх зберегти.
У разі зв'язків "один з багатьма" і "один з одним" поле зовнішнього ключа, оголошене у вторинній моделі, завжди зберігає безпосередньо об'єкт первинної
моделі, що представляє пов'язаний запис. Але у разі зв'язку ”багато хто зі-мно гімі” це не так— атрибут, що представляє поле, зберігає екземпляр класу
RelatedManager -диспетчер зворотного зв'язку.
Для встановлення зв'язків між записами потрібно користуватися такими методами цього класу.
add () — щоб додати зазначені записи до числа пов'язаних з поточним записом:
from testapp.models import Spare, Machine
si = Spare.objects.create(name='S')
s2 = Spare.objects.create(name='Bolt')
s3 = Spare.objects.create(name='Hummer')
s4 = Spare.objects.create(name='Crew')
ml = Machine.objects.create(name='Auto')
m2 = Machine.objects.create(name='Car')
ml. spares, add (si, s2)
ml.spares.all ()
<QuerySet [<Spare: Spare object (1)>, <Spare: Spare object (2)>]>
s 1. machine_set. al 1 ()
<QuerySet [<Machine: Machine object (1)>]>
ml.spares.add(s4)
ml.spares.all ()
create() — для створення нових записів зв'язаної моделі та одночасного зв'язування їх із поточним записом:
ml.spares.create(name=’Vint’)
<Spare: Spare object (5)>
ml.spares.all ()
<QuerySet [<Spare: Spare object (1)>, <Spare: Spare object (2)>z
<Spare: Spare object (4)>]z <Spare: Spare object (5)>]
set — те саме, що add(), але не додає зазначені записи до числа пов'язаних з поточним записом, а замінює ними ті, що були пов'язані з ній раніше. Якщо значення параметра bulk дорівнює True, то записи будуть пов'язані безпосередньо віддачею СУБД SQL-команди, без маніпуляцій з об'єктами моделей, що представляють записи, що зв'язуються. Ця поведінка за умовчанням, і вона дозволяє збільшити продуктивність. 
Якщо значення параметра bulk дорівнює False, то записи будуть зв'язуватися за допомогою маніпуляцій об'єктами моделі, що представляють записи, що зв'язуються. Це може стати в нагоді, якщо клас моделі містить перевизначені методи save() та delete(). 
Якщо значення параметра clear дорівнює True, Django спочатку очистить список пов'язаних записів, а потім зв'яже задані в методі запису з поточним записом. 
Якщо ж його значення дорівнює False, то зазначені записи, відсутні в списку пов'язаних, будуть додані до нього, а пов'язані записи, відсутні в послідовності вказаних у викликі методу, - видалені зі списку пов'язаних (поведінка за умовчанням). приклад
s5 = Spare.objects.get (pk=5)
ml .spares, set ([s2, s4, s5] )
ml .spares.all ()
<QuerySet [<Spare: Spare object (2)>z <Spare: Spare object (4)>z
<Spare: Spare object (5)>]>
remove — видаляє вказані записи зі списку пов'язаних із поточним записом
ml. spares. remove (s4)
ml. spares. all ()
<QuerySet [<Spare: Spare object (2)>z <Spare: Spare object (5)>]>
clear () — повністю очищає список записів, пов'язаних з поточною:
m2.spares.set ( [s1, s2, s3, s4, s5] )
m2.spares.all ()
<QuerySet [<Spare: Spare object (1)>, <Spare: Spare object (2)>, 
<Spare: Spare object (3)>, <Spare: Spare object (4)>,
<Spare: Spare object (5)>]
Якщо виникає потреба створити, виправити або видалити одразу велику кількість записів, то зручніше використовувати засоби Django для масового запису даних. Це такі методи класу Manager (вони також підтримуються похідним ВІД нього класом RelatedManager):
bulk_create — додає в модель запису, зазначені в послідовності. Параметр batch size визначає кількість записів, які будуть додані в одній SQL-команді. Якщо він не вказано, всі задані записи будуть додані в одній команді (за замовчуванням). Параметр ignore_conflicts з'явився в Django 2.2. Якщо йому задати значення False, то при спробі додати записи, що порушують задані в таблиці умови (наприклад, що містять неунікальні значення), буде порушено виключення integrityError (поведінка за умовчанням). Якщо параметр отримає значення True, винятки генеруватися не будуть, а записи, що порушують умови, просто не додадуться в таблицю. 
Увага! Деякі СУБД, зокрема Oracle, не підтримують ігнорування порушень умов, записаних у таблиці при додаванні записів. У такому разі при спробі викликати метод bulk create із зазначенням параметра ignore conflicts значення True буде порушено виключення NotSupportedError З модуля django.db.utils. 
Як результат повертається набір доданих до моделі записів, представлений екземпляром класу QuerySet. Увага! Метод bulk create() не створює об'єкти моделі, а безпосередньо відправляє СУБД SQL-команду, яка створює записи. Тому в записах, повернутих ним, ключове поле не заповнене. 
Виходячи з цього, потрібно пам'ятати, що метод save () у доданих таким чином записів не викликається. Якщо він перевизначений у моделі, щоб здійснити при збереженні будь-які додаткові дії, то ці дії виконані не будуть.
г = Rubric.objects.get(name=...)
GoITeen.objects .bulk_create ([...
update - виправляє всі записи в наборі, задаючи нові значення полів. Ці значення встановлюються у параметрах методу, одне іменних з потрібними полями моделі. Як результат повертається кількість виправлених записів. Метод save () у виправлюваних записів не викликається, що може бути критично, якщо останній перевизначений і виконує будь-які додаткові дії.
GoITeen.objects.filter(price__lt=40).update(price=40)
Записи, що виправляються, вибираються з моделі, після чого в їхні поля заносяться нові значення шляхом присвоювання відповідним атрибутам класу моделі . Послідовність виправлених таким чином записів передається методу першим параметром. Другим параметром вказується послідовність з імен полів, значення яких було виправлено. Параметр batch size визначає кількість записів, які будуть виправлені в одній команді SQL. Якщо він не вказаний, усі задані записи будуть виправлені в одній команді (стандартна поведінка). Метод save() у записів, що виправляються, у цьому випадку також не викликається.
b1 = GoITeen.objects.get(title=’Home’)
b2 = GoITeen.objects. get (title=’couch’)
bl.price = 1000000
b2.price = 200
GoITeen.objects.bulk_update((bl, b2) , (’price’,))
bl.price
1000000
b2.price
2000000
Вибірка даних
Механізм моделей Django підтримує розвинені засоби для вибірки даних.
Вилучення значень із полів запису
Отримати значення полів запису можна з атрибутів класу моделі, які представляють ці поля:
from GoITeenoard.models import GoITeen
b = GoITeen.objects.get(pk=l)
b.title
‘Home’
b.content
b.price
1000000.0
Якщо просто звернутися до якогось поля зі списком, ми отримаємо значення, яке безпосередньо зберігається в полі, а не те, яке має виводитися на екран:
b = GoITeen.objects.get (pk=l)
Кошти, призначені для доступу до пов'язаних записів і створювані самим фреймворком, відрізняються для різних типів зв'язків. Для зв'язку ”один з багатьма” з вторинної моделі можна отримати пов'язаний запис первинної моделі за допомогою атрибуту класу, що представляє поле зовнішнього ключа
b.rubric
Можна отримати значення будь-якого поля пов'язаного запису
b.rubric.name
У класі первинної моделі буде створено атрибут. Він зберігає диспетчер зворотного зв'язку, представлений екземпляром класу RelatedManager, який є похідним від класу диспетчера записів Manager і таким чином підтримує всі його методи. Диспетчер зворотного зв'язку, на відміну диспетчера записів, маніпулює лише записами, пов'язаними з поточним записом первинної моделі
from GoITeenoard.models import Rubric
Вибірка записів
Усі моделі підтримують атрибут класу об'єктів. Він зберігає диспетчер записів (примірник класу Manager), який дозволяє маніпулювати всіма записами, що зберігаються у моделі. 
Метод аll(), що підтримується класом Manager, повертає набір із усіх записів моделі у вигляді екземпляра класу Queryset. 
Останній має функціональність послідовності та підтримує ітераційний протокол. Отже, ми можемо просто перебрати записи набору і виконати над ними будь-які дії у звичайному циклі for.. .in. Приклад:
for г in Rubric.objects.all(): print(r.name, end=’ ’)
Пошук одного запису
Для пошуку запису заданим умовам служить метод get (<умови пошуку>). Умови пошуку записуються як іменованих параметрів, кожен із яких представляє однойменне поле. Значення, присвоєне такому параметру, задає значення для поля. Якщо запис, що збігається із заданими умовами, знайшовся, він буде повернений як результат. Якщо жодного відповідного запису не було знайдено, то буде порушено виняток DoesNotExist, клас якого є вкладеним у клас моделі, чий запис не був знайдений. Якщо підходящих записів виявилося кілька, збуджується виняток MultipleObjectsReturned З модуля django.core.exceptions
Rubric.objects.get(name=’Plants’)
Rubric.objects.get(pk=5, name=..)
b = GoITeen.objects.get (pk=l)
Сортування записів
Для сортування записів у наборі застосовується метод order by ():
Як параметри вказуються імена полів у вигляді рядків. Спочатку сортування виконується за значенням першого поля. Якщо в якихось записів воно зберігає те саме значення, проводиться сортування по другому полю і т.д.
За умовчанням сортування виконується за зростанням значення поля. Щоб відсортувати за зменшенням значення, слід передувати ім'я поля знаком "мінус".
Пара прикладів:
for г in Rubric.objects.order_by(’name1): print(r.name, end=’ ’
for b in GoITeen.objects.order_by(’rubric__name’, ’price’):
print(b.title, end=’ ’)
Агрегатні обчислення
Агрегатні обчислення торкаються значення певного поля всіх записів, що є в моделі, або груп записів, що задовольняють будь-якій умові. До такого роду дій відноситься обчислення числа оголошень, середнього арифметичного ціни, найменшого і найбільшого значення ціни і т. п. Кожна з можливих дій, що виконуються при агрегатних обчисленнях, надається певною агрегатною функцією. Так, існують агрегатні функції для підрахунку числа записів, середнього арифметичного, мінімуму, максимуму та ін. Якщо потрібно провести агрегатне обчислення по всіх записах моделі, немає нічого кращого за метод aggregate (): 
Одразу відзначимо два моменти. По-перше, агрегатні функції є екземплярами особливих класів, які оголошені в модулі django.db.models і які ми розглянемо трохи пізніше. По-друге, результат, що повертається методом, — словник Python, в якому окремі елементи представляють результати виконання відповідних їм агрегатних функцій. Агрегатні функції можна вказати у вигляді як позиційних, так і іменованих параметрів: 
якщо агрегатна функція вказана у вигляді позиційного параметра, то в результуючому словнику буде створено елемент з ключем. Зберігає результат виконання цієї функції. Наприклад визначимо найменше значення ціни, вказане в оголошеннях
from django. db. modeIs import Min
GoITeen.objects.aggregate (Min (’ price ’) )
якщо агрегатна функція зазначена у вигляді іменованого параметра, то ключ елемента, створюваного у словнику, збігатиметься з ім'ям цього параметра. З'ясуємо найбільше значення ціни в оголошеннях:
from django.db.modeIs import Max
GoITeen.objects.aggregate(max_price=Max('price'))
Функція СУБД обробляється не Django і Python, а СУБД. Django просто надає для цих функцій зручний об'єктний інтерфейс. Функції СУБД використовуються у викликах методу annotate і представляються ледь ДУЮЧИМИ класами З модуля django.db.models.functions: 
Coalesce — повертає перше передане йому значення, відмінне від null (навіть якщо це порожній рядок або 0). Значення видаються рядковими іменами полів, екземплярами класів f і value. Всі вони повинні мати однаковий тип (наприклад, лише рядковий або лише числовий), інакше ми отримаємо помилку. 
Приклад: Coalesce('content*, 'addendum', Value(')) 
Якщо значення поля content відмінно від null, буде повернуто воно. У протилежному випадку буде перевірено значення поля addendum і, якщо воно не дорівнює null, функція поверне його. Якщо ж значення поля addendum дорівнює null, то буде повернуто константа ' —порожньо—';
Greatest —повертає найбільше значення з переданих йому. Значення видаються рядковими іменами полів, екземплярами класів f і value. Всі вони повинні мати однаковий тип (наприклад, тільки рядковий або лише числовий), інакше ми отримаємо помилку
from django.db.models.functions import Greatest
for b in GoITeen.objects.annotate(gp=Greatest('price', 1000)):
print(b.title, ': ', b.gp)

Домашне завдання
Повторити увесь код який був написан по двум темам.
Додати до минулого домашнього завдання ще три класи, з’єднати їх за допомогою трьох зв'язків, один до одного, один до багатьох та багато до багатьох.
